import { Project } from 'ts-morph';
import { transformer } from './transformer/transformer';
import { isTypeDeclaration, TypeDeclaration } from './types';
import { codeGenerator } from './codeGenerator/codeGenerator';
import path from 'path';
import { makeAsync } from './utils';

export const generateOneWrongTypeReport = async ({
    filePath,
    customProject,
    outDirPath,
    onlyExport,
}: {
    filePath: string;
    customProject?: Project;
    outDirPath?: string;
    onlyExport?: boolean;
}) => {
    await makeAsync();
    if (!outDirPath) {
        outDirPath = path.dirname(filePath);
    }

    const project =
        customProject ||
        new Project({
            tsConfigFilePath: 'tsconfig.json',
        });

    const sourceFile = project.getSourceFile(filePath);
    if (!sourceFile) {
        throw new Error(`No sourcefile at ${filePath}`);
    }

    const exports = Array.from(sourceFile.getExportedDeclarations().values())
        .flat()
        .filter((ex) => ex.getSourceFile() === sourceFile);

    const exportedTypeDeclarations = exports.filter(isTypeDeclaration);

    // Get all type declarations
    const typesDeclarations: TypeDeclaration[] = onlyExport
        ? exportedTypeDeclarations
        : [
              ...sourceFile.getInterfaces(),
              ...sourceFile.getTypeAliases(),
              ...sourceFile.getEnums(),
          ];

    // Get new AST
    const newAsts = typesDeclarations.map((typeDeclaration) => {
        return transformer(typeDeclaration);
    });

    // Generate guard then add to SourceFile
    await Promise.all(
        newAsts.map((ast) => {
            return codeGenerator({
                astRootNode: ast,
                project,
                outFilePath: `${outDirPath}/${ast.ast.name}.guard.ts`,
                inputSourceFile: sourceFile,
            });
        }),
    );
};

export const generateWrongTypeReport = async ({
    filePaths,
    customProject,
    outDirPath,
    onlyExport,
}: {
    filePaths: string[];
    customProject?: Project;
    outDirPath?: string;
    onlyExport?: boolean;
}) => {
    await makeAsync();
    await Promise.all(
        filePaths.map((filePath) => {
            return generateOneWrongTypeReport({
                filePath,
                customProject,
                outDirPath,
                onlyExport,
            });
        }),
    );
};

export type GeneratedWrongTypeErrorReport = {
    propertyName: string;
    propertyChainTrace: string[];
    received: any;
    expectedType: string;
}[];

/**
 * generateReporter
 *
 * Generates a reporter function that takes in a reporter function generated by wrong-type-report-generator
 *
 * @param onError perform action when there is an error report
 * @param onNotError perform action when there is no error report
 * @returns Reporter function
 */
export const generateReporter =
    (
        onError: (errorReport: GeneratedWrongTypeErrorReport) => void,
        onNotError?: () => void,
    ) =>
    /**
     * @param reporter function that is generated by wrong-type-report-generator
     * @returns function that takes in an object to validate
     */
    <T>(
        reporter: (
            toValidate: unknown,
        ) => GeneratedWrongTypeErrorReport | undefined,
    ) =>
    (fromApi: T) => {
        try {
            const errorReport = reporter(fromApi);
            if (errorReport) {
                onError(errorReport);
            } else {
                onNotError?.();
            }
        } catch {}
        return fromApi;
    };
